\section{The Necessity of lists}

Let us for the sake of originality work on a new problem.
\begin{quotation}     A lecturer for an introductory programming course wants to record    some information about his students. He wants to keep a record of    each student's name, their primary field of study, and a brief    description of their current research project. He would like to be    able to print this out in a nicely formatted way. His class has 19    students.    
\end{quotation}

For each student we need to record their name, field of study, and a   description of their research project. This means three values we need   to store for each student, or 38 variables in total. Surely there's a   better way. There is, and Python yet again provides us with the perfect   tool for job, the \textbf{list}!

A list is a \textbf{type} of variable. To create a new   variable of type list in Python simply assign a list to a variable.   Lists are formed using square brackets surrounding a comma-separated   sequence of the elements of the list.  Example:
\begin{lstlisting}
>>> mylist = [1, 2, 3]
>>> anotherlist = ["Alice", "Bob", "Carl", "Mallory"]
>>> mixed = ["a string", 143, [341]]
>>> empty = []
>>>
\end{lstlisting}
\begin{itemize}
	\item Lists contain elements, e.g. \texttt{mylist} contains three elements,    namely 1, 2, and 3.
	\item Lists have length, being the number of elements they contain,    e.g. \texttt{mylist} has length 3, \texttt{anotherlist} has length 4
	\item We can determine the length of a list using Python's built in    \texttt{len}    function
\begin{lstlisting}
>>> len([1, 2, 3])
3
\end{lstlisting}
	\item The elements of a list can be expressions of any type    (including another list) and different elements in the same list    can be of different types, e.g. \texttt{mixed} has three elements; the    first element is a string (\texttt{"a string"}), the second element is an    integer (\texttt{143}), and the third element is another list (\texttt{[341]}).
	\item Lists can contain no elements, in which case they are known as    \textit{empty}, e.g. \texttt{empty} contains no elements, but is still a list!
	\item Individual elements of a list are indexed according to their    position in the list. The first position has an index of 0, the    second position an index of 1, etc\ldots
	\item We can access a specific element in a list by using a special    operator in an expression with the format    
\texttt{list[index]}. This expression evaluates to the element    in the index'th position of the list. e.g. 
\texttt{mylist[0]}    is 1, 
\texttt{mylist[1]} is 2, 
\texttt{mixed[2]} is    \texttt{[341]}.
\end{itemize}

Now that we know about lists, we could use a list to represent the   students names, another to represent their fields of study, and a third   to represent their project descriptions. So we might have
\begin{lstlisting}
#a small program to record info about students

name = ["Ayanda", "Ben", "Carl", "Dumisani"]
field = ["Astronomy", "Biochemistry", "Cancer Research", "Maths"]
description = [
    "The search for black holes",
    "Engineering a better yeast for brewing beer",
    "Better pain management in palliative care",
    "Finding a polynomial time solution for NP-complete problems"
]
\end{lstlisting}

\section{Lists in Detail}

We've already learnt a little about about lists, but there are many   more features to lists, and sadly a   few intricacies we need to know about. Firstly let's deal more   explicitly with the operations that can be performed on lists. If both   \texttt{a} and \texttt{b} are lists, \texttt{v} is any expression, and \texttt{i}, \texttt{j}, and \texttt{k} are   integers then
\begin{itemize}
	\item 
\texttt{a + b} concatenates (joins) two lists. \\
It returns a new list that contains all the elements of list \texttt{a} and then list \texttt{b}.
\begin{lstlisting}
>>> a = [1,2,3]
>>> a+[4,5]
[1, 2, 3, 4, 5]
>>>
>>> [4,5]+a
[4, 5, 1, 2, 3]
\end{lstlisting}
	\item 
\texttt{a * i} repeats a list. \\
It returns a new list with that has all the elements of \texttt{a} but repeated \texttt{i} times.
\begin{lstlisting}
>>> a*2
[1, 2, 3, 1, 2, 3]
>>>
>>> [1]*2+2*[2]
[1, 1, 2, 2]
>>>
>>> [[1]*2,[2]*2]
[[1, 1], [2, 2]]
>>>
>>> [1]*2*3
[1, 1, 1, 1, 1, 1]
>>>
\end{lstlisting}
	\item 
\texttt{a[i]} retrieves the \texttt{i}'th element of    \texttt{a}.
\begin{lstlisting}
>>> a[0]
1
\end{lstlisting}
	\item 
\texttt{a[i:j:k]} slices the list. \\
It returns a copy of the list \texttt{a}    from its \texttt{i}'th element to its \texttt{(j-1)}'th element, taking only every    \texttt{k}'th element. If \texttt{k} is omitted (left out), every element in the range is    taken. If \texttt{i} or \texttt{j} are omitted they default to beginning of list    and end of list respectively.
\begin{lstlisting}
>>> a[1:3]
[2, 3]
>>> a += [4, 5]
>>> a[0:6:2]
[1, 3, 5]
\end{lstlisting}
	\item 
\texttt{a[:i]} yields a slice from the beginning of \texttt{a} to    the \texttt{(i-1)}'th element of \texttt{a}.
\begin{lstlisting}
>>> a[:3]
[1, 2, 3]
\end{lstlisting}
	\item 
\texttt{a[i:]} yields a slice from the \texttt{i}'th element to the    end of the list.
\begin{lstlisting}
>>> a[3:]
[4, 5]
\end{lstlisting}
	\item 
\texttt{a[:]} yields a slice of the entire list. More    importantly it yields a \textbf{copy} of the list!
\begin{lstlisting}
>>> a[:]
[1, 2, 3, 4, 5]
>>>
\end{lstlisting}
\end{itemize}

Note that theses operators each return newly created lists, and do   not modify the \textit{operand} lists (that is, the list that this operations are performed on) in any way. 








\section{Assignment to elements of a list}

Lists can have their elements changed.   This sounds a little weird, but consider it this way. The value of the   integer 1 cannot change. We can change the value indicated by a   variable \texttt{i} (which might be 1) to something else, but this doesn't   change the value of the integer 1. Lists are different, because the   value reflects a container of multiple other values, and we can remove,   add, or replace those inner values, i.e. list elements. This changes   the value of the list itself. Practically, this means we can assign   values to specific elements of a list.


\begin{lstlisting}
>>> a = [1, 2, 3]
>>> a[0]
1
>>> a[0] = 0
>>> a
[0, 2, 3]
>>> 
\end{lstlisting}

Not only can we assign individual elements of a list a new value,   but we can assign whole slices new values. The funky thing is, we can   replace a specified slice of a list with a list of any length,   effectively extending or shrinking the list in the process.


\begin{lstlisting}
>>> a = [1, 2, 5]
>>> a[1:2] = [3]
>>> a
[1, 3, 5]
>>> a[1:2] = [2, 3, 4]
>>> a
[1, 2, 3, 4, 5]
>>> a[1:4] = [3]
>>> a
[1, 3, 5]
>>> 
\end{lstlisting}

\section{Comparing Lists}

The comparison of lists to other lists, and other types is also   slightly different to the comparison of simple types (int, float,   bool). Specifically:
\begin{itemize}
	\item 
\texttt{a == b} checks two lists are the same. \\
It returns true if all the elements of \texttt{a} are the same as the elements of \texttt{b}.
	\item 
\texttt{a < b} yields Less Than. \\
Note that lists are    compared in sequence order, meaning that \texttt{a} is less than \texttt{b} if    \texttt{a}'s first element is less than \texttt{b}'s first element. If \texttt{a}'s first    element and \texttt{b}'s first element are equal, the second elements are    checked, etc\ldots
	\item 
\texttt{v in a} is True only if the list a contains an    element whose value is that of the expression \texttt{v}.
	\item 
\texttt{a is b} is True only if \texttt{a} and \texttt{b} are the same    list.
\end{itemize}

Note the final point, namely the \texttt{is} operator. This is one of those   intricacies we mentioned earlier. The contents of a list can be   changed. This is not true of an integer for example. One cannot change   the contents of the integer 1. This introduces a slight complexity. If   \texttt{a} is 1 and \texttt{b} is 1 then \texttt{a} and \texttt{b} are the same. But if 
\texttt{a =   [1]}, and 
\texttt{b = [1]}, they \textbf{are not} the   same. They may be equal, but are not the same list. They are different   lists. Again, examples to the rescue
\begin{lstlisting}
>>> a = [1,2]
>>> b = [1,2]
>>> a == b
True
>>> a is b
False
>>>
>>> b[0] = 3
>>> b
[3, 2]
>>> a
[1, 2]
>>>
\end{lstlisting}
\begin{lstlisting}
>>> a = [1,2]
>>> b = a
>>> a == b
True
>>> a is b
True
>>> b[0] = 3
>>> b
[3, 2]
>>> a
[3, 2]
>>>
\end{lstlisting}

Note how the second line of the second example contradicts our basic idea   of assignment, which was: The assignment statement assigns the value of   the expression on the right to the variable on the left. But clearly,   we are not just assigning the value (\texttt{[1,2]}), because later when we   change the first element of \texttt{b} to 3, we also appear to change the   first element of \texttt{a}. Weird. There is a technical explanation for this,   but is really not worth knowing at this point as it is more likely to   confuse than clarify. If you are interested, ask one of the tutors to explain this. What this does mean however is that we need to be   aware of the special case of assignment to a single variable of   types that can be changed!     When, in an assignment statement 
\texttt{a = b}, if \texttt{b} is of    \textbf{mutable type} (a type that can have its values     changed), the assignment statement    \textbf{makes \texttt{a} a synonym of \texttt{b}}, i.e. they become    different names for the same variable.    

Also note how we assigned a value to an element of the list,   changing some of its contents. Python is quite advanced in terms of   how it can handle assignments involving lists, so let's explore its   features a bit. If \texttt{a} is the list \texttt{[1, 2, 3]}, \texttt{b} is some expression of   any value, and \texttt{l} is some expression of type list.
\begin{itemize}
	\item 
\texttt{a[0] = b} assigns the value of \texttt{b} to the 0'th    element of \texttt{a}. (The mutable type special case applies)
	\item 
\texttt{a[0:2] = l} removes the slice range specified on    the left and replaces the removed elements with the contents of    \texttt{l}. This does \textbf{not} make \texttt{a} and \texttt{l} synonyms.
\end{itemize}

If we wish to make a copy of a list that is not a synonym, we assign   to the slice of the full list, e.g. 
\texttt{a = b[:]} (where \texttt{b} is   a list)

\section{Lists as objects}

In addition to the operators that can act on lists, list are   objects. An \textbf{object} is a term used in Computer Science to   refer specifically to something which has both code and data associated   with it directly. For now, a complete understanding of objects is not required, but in the meanwhile we need to be aware of some   syntactical features they provide.

Objects have code associated with them in functions called   \textbf{methods}. Methods are bound to every variable of an   object type individually, meaning if two different variables, \texttt{a} and   \texttt{b}, are of the same type which is an object type, then \texttt{a} and \texttt{b}   both have the same set of methods but their methods are distinct from   one another. When \texttt{a} calls a method, that method acts only on \texttt{a}, and   when \texttt{b} calls that same method, the method will act only on \texttt{b}. Read   it again, it makes sense. In fact examples will prove it's quite   intuitive.
\begin{lstlisting}
>>> a = [1, 2, 3]
>>> b = ["A", "B", "C"]
>>> a.index(2)
1
>>> b.index(2)
Traceback (most recent call last):
  File "", line 1, in 
ValueError: 2 is not in list
>>> b.index("C")
2
\end{lstlisting}

Looking at the examples we notice there is some new notation, of the   form 
\texttt{$<$list$>$.$<$method$>$()}. This \textit{dot notation}   indicates that we are obtaining a method of the list object (called   index in the case of the example), and our use of brackets indicates we   wish to call it.     Methods are simply functions associated with a particular type.    

Note that 
\texttt{a.index(2)} and 
\texttt{b.index(2)} return   different results. In fact the \texttt{b.index} case produces an error.   Obviously they are doing different things, despite being given the same   parameter (\texttt{2}). What the index method does is search for a given value   in the elements of \textbf{its} list. When called using   \texttt{a.index} its list is \texttt{a}, when called using \texttt{b.index} its list is \texttt{b}.   Since the value 2 is an element of the list \texttt{a}, index returns its   index position (1), meaning it can be found in the second position in   the list. But the value 2 is not an element of the list \texttt{b}, hence   index will cause an error.

That being said, let's round off our knowledge of lists by   going through the list methods that will be useful to us.
\begin{itemize}
	\item 
\texttt{$<$list$>$.append($<$expression$>$)}
\\     Appends the value of $<$expression$>$ to the end of     $<$list$>$.      
\begin{lstlisting}
>>> a = []
>>> a.append('one')
>>> a
['one']
>>>
\end{lstlisting}
	\item 
\texttt{$<$list$>$.count($<$expression$>$)}
\\     Returns the number of elements in $<$list$>$ with same value     as that of $<$expression$>$.      
\begin{lstlisting}
>>> a = ['a', 'c', 'g', 't', 't', 'a']
>>> a.count('a')
2
>>>
\end{lstlisting}
	\item 
\texttt{$<$list$>$.index($<$expression$>$)}
\\     Returns the index of the first element in $<$list$>$ that has     the same value as $<$expression$>$.      
\begin{lstlisting}
>>> a = ['a', 'c', 'g', 't', 't', 'a']
>>> a.index('t')
3
>>>
\end{lstlisting}
	\item 
\texttt{$<$list$>$.insert($<$index expression$>$, $<$object     expression$>$)}
\\ Inserts the value of $<$object     expression$>$ \textbf{before} the element at the     position indicated by $<$index expression$>$.      
\begin{lstlisting}
>>> a = ['a', 'c', 'g', 't', 't', 'a']
>>> a.insert(2,'newitem')
>>> a
['a', 'c', 'newitem', 'g', 't', 't', 'a']
>>>
\end{lstlisting}
	\item 
\texttt{$<$list$>$.pop()}
\\ Removes the last element     from the end of the list, and returns it's value.      
\begin{lstlisting}
>>> a = ['a', 'c', 'g', 't', 't', 'a']
>>> a.pop()
'a'
>>> a
['a', 'c', 'g', 't', 't']
>>>
\end{lstlisting}
	\item 
\texttt{$<$list$>$.remove($<$expression$>$)}
\\     Removes the first element in $<$list$>$ that has the same     value as $<$expression$>$.      
\begin{lstlisting}
>>> a = ['a', 'c', 'newitem', 'g', 't', 't', 'a']
>>> a.remove('newitem')
>>> a
['a', 'c', 'g', 't', 't', 'a']
>>>
\end{lstlisting}
	\item 
\texttt{$<$list$>$.reverse()}
\\ Reverses the order of     elements in $<$list$>$.      
\begin{lstlisting}
>>> a = ['alpha', 'beta', 'gamma', 'delta']
>>> a.reverse()
>>> a
['delta', 'gamma', 'beta', 'alpha']
>>>
\end{lstlisting}
	\item 
\texttt{$<$list$>$.sort()}
\\ Sorts the elements of     $<$list$>$.      
\begin{lstlisting}
>>> a = ['delta', 'gamma', 'beta', 'alpha']
>>> a.sort()
>>> a
['alpha', 'beta', 'delta', 'gamma']
>>>
\end{lstlisting}
\end{itemize}
% 
%     <h2>List Comprehensions</h2>
% 
% 		<p>A list comprehension is a special syntactic element of the python
% 		language that allows rapid construction of a new list from the elements
% 		of an old list. They are a syntactic contraction of the pattern:</p>
% 
% <pre class='listing'>
% new_list = []
% for element in old_list:
%     new_list.append(&lt;something done with element&gt;)
% </pre>
% 
% 		<p>List comprehensions have the following basic syntax:</p>
% 
% <pre class='definition'>
% [&lt;expression of <em>e</em>&gt; for <em>e</em> in &lt;old_list&gt;]
% </pre>
% 		<p>The list comprehension is an expression itself which evaluates as a
% 		list containing the results of the expression of <em>e</em> as each
% 		element applied to the <em>e</em>'s of the old list. Example time:</p>
% 
% <pre class='listing'>
% &gt;&gt;&gt; [e for e in [2, 4, 5]]
% [2, 4, 5]
% &gt;&gt;&gt; [2*e for e in [2, 4, 5]]
% [4, 8, 10]
% &gt;&gt;&gt; [e*e for e in [2, 4, 5]]
% [4, 16, 25]
% &gt;&gt;&gt; [0 for e in [2, 4, 5]]
% [0, 0, 0]
% &gt;&gt;&gt; dwarfs = [
% ... 'Happy',
% ... 'Grumpy',
% ... 'Sleepy',
% ... 'Sneezy',
% ... 'Doc',
% ... 'Bashful',
% ... 'Dopey']
% &gt;&gt;&gt; [n.startswith('S') for n in dwarfs]
% [False, False, True, True, False, False, False]
% &gt;&gt;&gt; [n.endswith('y') for n in dwarfs]
% [True, True, True, True, False, False, True]
% &gt;&gt;&gt; [[i]*3 for i in range(3)]
% [[0, 0, 0], [1, 1, 1], [2, 2, 2]]
% </pre>
% 
% 		<p>Additionally we can select which elements we want to bring in from
% 		our old list into our new one using a filter clause.<p>
% 
% <pre class='definition'>
% [&lt;expression of <em>e</em>&gt; for <em>e</em> in &lt;old_list&gt; if &lt;some other expression of <em>e</em>&gt;]
% </pre>
% 		
% 		<p>Using a filter clause our new list may not have as many elements as
% 		out old list. Let's get only dwarfs names if they start with 'S':</p>
% 
% <pre class='listing'>
% >>> [n for n in dwarfs if n.startswith('S')]
% ['Sleepy', 'Sneezy']
% </pre>
% 		
%     <p>How cool is this?</p>
% 


\section{Exercises}

\begin{enumerate}
\item Given the list 
\texttt{l = ['There', 'are', 9000000, 'bicycles', 'in', 'Beijing']}
\begin{enumerate}
	\item How many elements does the list have? How would one find this    out programatically?
	\item What is the index of the non-string element?
	\item What is the output of 
\texttt{print(l[1:4])}?
\end{enumerate}
	\item What is the value of 
\texttt{[1, 3] + [2, 4]}?
	\item What is the value of 
\texttt{[1, 3] + [[2, 4]]}?
	\item What is the difference between appending a value to a list and    adding the same value within its own list using the concatenation    operator?
	\item What is the slice notation to extract the word \texttt{`mickles'} from    the string \texttt{`How many mickles are there in a    muckle?'}
% 
% 			<li>Write a list comprehension that produces a list of 3 lists of
% 			length 3, where	each inner list starts with an integer one greater
% 			than the start of the previous list, and the first list starts at
% 			zero.</li>
% 
% 			<li>Write a list comprehension that contains a two element list for
% 			each letter of the alphabet, which contains as its first element,
% 			the letter of the alphabet, and its second element a boolean value
% 			representing whether any of the dwarf names start with that
% 			letter.</li>
% 
% 			<li>Modify your answer to question 6 to contain the number of dwarf
% 			names beginning with each letter, instead of simply True or False.
% 			</li>
% 

	\item Write a program that outputs the position of every \texttt{`t'} in the    list \texttt{[`a', `c', `g', `t', `t', `a', `t']}. Use the index method,    don't do it manually.
	\item Write a program that asks the user to enter a sequence of up to    5 x:y coordinates with both x and y in the range 0 to 4, ending    their sequence entry by providing a blank line for the x    coordinate. Then display a five by five grid of `\#' characters,    with the points in the grid entered by the user left blank. Assume    x increases from left to right, and y increases from top to bottom.    Example input/output is given \ldots          
\begin{lstlisting}
Coordinates range from 0 to 4!
Please enter pair of coordinates (x:y), leave x blank to terminate sequence.
X> 3
Y> 3
Please enter pair of coordinates (x:y), leave x blank to terminate sequence.
X> 4
Y> 1
Please enter pair of coordinates (x:y), leave x blank to terminate sequence.
X> 1
Y> 4
Please enter pair of coordinates (x:y), leave x blank to terminate sequence.
X>
#####
#### 
#####
### #
# ###
\end{lstlisting}
\end{enumerate}
